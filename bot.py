# bot.py
import os
import re
import pandas as pd
from flask import Flask, request
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    ContextTypes,
    filters,
)
from aliases import ALIASES

# === –ù–∞—Å—Ç—Ä–æ–π–∫–∏ ===
TOKEN = "8442487432:AAFmTCgUAt57UcJhSbMool1IsCi8snOIPEs"
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
COCKTAILS_FILE = os.path.join(BASE_DIR, "tech_cards_coctail_rambling.xlsx")
ZAGOTOVKI_FILE = os.path.join(BASE_DIR, "tech_cards_zagi.xlsx")
TINCTURES_FILE = os.path.join(BASE_DIR, "tech_cards_tinctures.xlsx")

# Flask-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
app = Flask(__name__)
application = Application.builder().token(TOKEN).build()

# ---------- –£—Ç–∏–ª–∏—Ç—ã ----------
def normalize_text(s: str) -> str:
    s = (s or "").strip().lower()
    s = s.replace("—ë", "–µ")
    s = re.sub(r"[\"‚Äú‚Äù‚Äû‚Äô']", " ", s)
    s = re.sub(r"\s+", " ", s)
    return s

def resolve_alias(user_text: str) -> str:
    t = normalize_text(user_text)
    mapped = ALIASES.get(t, t)
    return normalize_text(mapped).replace("_", " ").strip()

# ---------- –ó–∞–≥—Ä—É–∑–∫–∞ Excel ----------
COL_SYNONYMS = {
    "–Ω–∞–∑–≤–∞–Ω–∏–µ": "–Ω–∞–∑–≤–∞–Ω–∏–µ",
    "name": "–Ω–∞–∑–≤–∞–Ω–∏–µ",
    "–∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã": "–∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã",
    "–∏–Ω–≥—Ä–∏–¥–∏–µ–Ω—Ç—ã": "–∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã",
    "—Å–æ—Å—Ç–∞–≤": "—Å–æ—Å—Ç–∞–≤",
    "–≥—Ä–∞–º–º–æ–≤–∫–∞": "–≥—Ä–∞–º–º–æ–≤–∫–∞",
    "–ø–æ—Å—É–¥–∞": "–ø–æ—Å—É–¥–∞",
    "–º–µ—Ç–æ–¥": "–º–µ—Ç–æ–¥",
    "–≥–∞—Ä–Ω–∏—à": "–≥–∞—Ä–Ω–∏—à",
    "–ø—Ä–∏–≥–æ—Ç–æ–≤–ª–µ–Ω–∏–µ": "–ø—Ä–∏–≥–æ—Ç–æ–≤–ª–µ–Ω–∏–µ",
    "–≤—ã—Ö–æ–¥": "–≤—ã—Ö–æ–¥",
}

def canon_columns(df: pd.DataFrame) -> pd.DataFrame:
    ren = {}
    for c in df.columns:
        key = normalize_text(str(c))
        ren[c] = COL_SYNONYMS.get(key, key)
    return df.rename(columns=ren)

def load_table(path: str, kind: str) -> pd.DataFrame:
    df = pd.read_excel(path)
    df = canon_columns(df).ffill()
    if "–Ω–∞–∑–≤–∞–Ω–∏–µ" not in df.columns:
        df.insert(0, "–Ω–∞–∑–≤–∞–Ω–∏–µ", df.iloc[:, 0].astype(str))
    df["–Ω–∞–∑–≤–∞–Ω–∏–µ"] = df["–Ω–∞–∑–≤–∞–Ω–∏–µ"].astype(str).apply(normalize_text)
    print(f"‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ {kind}: {df['–Ω–∞–∑–≤–∞–Ω–∏–µ'].nunique()} —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –∏–º—ë–Ω")
    return df

cocktails_df = load_table(COCKTAILS_FILE, "–∫–æ–∫—Ç–µ–π–ª–µ–π")
zagi_df      = load_table(ZAGOTOVKI_FILE, "–∑–∞–≥–æ—Ç–æ–≤–æ–∫")
tinct_df     = load_table(TINCTURES_FILE, "–Ω–∞—Å—Ç–æ–µ–∫")

# ---------- –§–æ—Ä–º–∞—Ç—Ç–µ—Ä—ã ----------
def format_cocktail(name: str) -> str:
    g = cocktails_df[cocktails_df["–Ω–∞–∑–≤–∞–Ω–∏–µ"] == name]
    if g.empty:
        return "‚ùå –ù–µ –Ω–∞—à—ë–ª –∫–æ–∫—Ç–µ–π–ª—å."
    text = f"üç∏ *{name.title()}*\n\n"
    if "–ø–æ—Å—É–¥–∞" in g: text += f"ü•É –ü–æ—Å—É–¥–∞: {g['–ø–æ—Å—É–¥–∞'].iloc[0]}\n"
    if "–º–µ—Ç–æ–¥" in g: text += f"üõ† –ú–µ—Ç–æ–¥: {g['–º–µ—Ç–æ–¥'].iloc[0]}\n"
    if "–≥–∞—Ä–Ω–∏—à" in g: text += f"üåø –ì–∞—Ä–Ω–∏—à: {g['–≥–∞—Ä–Ω–∏—à'].iloc[0]}\n\n"
    if "—Å–æ—Å—Ç–∞–≤" in g and "–≥—Ä–∞–º–º–æ–≤–∫–∞" in g:
        for _, r in g.iterrows():
            text += f"‚Äî {r['—Å–æ—Å—Ç–∞–≤']} ‚Äî {r['–≥—Ä–∞–º–º–æ–≤–∫–∞']}\n"
    return text

def format_zagotovka(name: str) -> str:
    g = zagi_df[zagi_df["–Ω–∞–∑–≤–∞–Ω–∏–µ"] == name]
    if g.empty:
        return "‚ùå –ù–µ –Ω–∞—à—ë–ª –∑–∞–≥–æ—Ç–æ–≤–∫—É."
    text = f"üß™ *{name.title()}*\n\n"
    if "–∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã" in g and "–≥—Ä–∞–º–º–æ–≤–∫–∞" in g:
        for _, r in g.iterrows():
            text += f"‚Äî {r['–∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã']} ‚Äî {r['–≥—Ä–∞–º–º–æ–≤–∫–∞']}\n"
    if "–ø—Ä–∏–≥–æ—Ç–æ–≤–ª–µ–Ω–∏–µ" in g: text += f"\nüõ† –ú–µ—Ç–æ–¥: {g['–ø—Ä–∏–≥–æ—Ç–æ–≤–ª–µ–Ω–∏–µ'].iloc[0]}"
    if "–≤—ã—Ö–æ–¥" in g: text += f"\nüì¶ –í—ã—Ö–æ–¥: {g['–≤—ã—Ö–æ–¥'].iloc[0]}"
    return text

def format_tincture(name: str) -> str:
    g = tinct_df[tinct_df["–Ω–∞–∑–≤–∞–Ω–∏–µ"] == name]
    if g.empty:
        return "‚ùå –ù–µ –Ω–∞—à—ë–ª –Ω–∞—Å—Ç–æ–π–∫—É."
    text = f"üß™ *{name.title()}*\n\n"
    if "–∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã" in g and "–≥—Ä–∞–º–º–æ–≤–∫–∞" in g:
        for _, r in g.iterrows():
            text += f"‚Äî {r['–∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã']} ‚Äî {r['–≥—Ä–∞–º–º–æ–≤–∫–∞']}\n"
    if "–º–µ—Ç–æ–¥" in g: text += f"\nüõ† –ú–µ—Ç–æ–¥: {g['–º–µ—Ç–æ–¥'].iloc[0]}"
    return text

# ---------- –•–µ–Ω–¥–ª–µ—Ä—ã ----------
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [InlineKeyboardButton("üç∏ –ö–æ–∫—Ç–µ–π–ª–∏", callback_data="list_cocktails")],
        [InlineKeyboardButton("üß™ –ó–∞–≥–æ—Ç–æ–≤–∫–∏", callback_data="list_zagi")],
        [InlineKeyboardButton("üß™ –ù–∞—Å—Ç–æ–π–∫–∏", callback_data="list_tinct")],
    ]
    await update.message.reply_text("üëã –ü—Ä–∏–≤–µ—Ç! –í—ã–±–µ—Ä–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:", reply_markup=InlineKeyboardMarkup(keyboard))

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = resolve_alias(update.message.text)
    if query in cocktails_df["–Ω–∞–∑–≤–∞–Ω–∏–µ"].values:
        await update.message.reply_text(format_cocktail(query), parse_mode="Markdown")
    elif query in zagi_df["–Ω–∞–∑–≤–∞–Ω–∏–µ"].values:
        await update.message.reply_text(format_zagotovka(query), parse_mode="Markdown")
    elif query in tinct_df["–Ω–∞–∑–≤–∞–Ω–∏–µ"].values:
        await update.message.reply_text(format_tincture(query), parse_mode="Markdown")
    else:
        await update.message.reply_text("‚ùå –ù–µ –Ω–∞—à—ë–ª. –ü–æ–ø—Ä–æ–±—É–π –¥—Ä—É–≥–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ.")

async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    if query.data == "list_cocktails":
        names = sorted(cocktails_df["–Ω–∞–∑–≤–∞–Ω–∏–µ"].unique())
        kb = [[InlineKeyboardButton(n.title(), callback_data=f"cocktail_{n}")] for n in names[:20]]
        await query.message.reply_text("üç∏ –í—ã–±–µ—Ä–∏ –∫–æ–∫—Ç–µ–π–ª—å:", reply_markup=InlineKeyboardMarkup(kb))
    elif query.data == "list_zagi":
        names = sorted(zagi_df["–Ω–∞–∑–≤–∞–Ω–∏–µ"].unique())
        kb = [[InlineKeyboardButton(n.title(), callback_data=f"zagi_{n}")] for n in names[:20]]
        await query.message.reply_text("üß™ –í—ã–±–µ—Ä–∏ –∑–∞–≥–æ—Ç–æ–≤–∫—É:", reply_markup=InlineKeyboardMarkup(kb))
    elif query.data == "list_tinct":
        names = sorted(tinct_df["–Ω–∞–∑–≤–∞–Ω–∏–µ"].unique())
        kb = [[InlineKeyboardButton(n.title(), callback_data=f"tinct_{n}")] for n in names[:20]]
        await query.message.reply_text("üß™ –í—ã–±–µ—Ä–∏ –Ω–∞—Å—Ç–æ–π–∫—É:", reply_markup=InlineKeyboardMarkup(kb))
    elif query.data.startswith("cocktail_"):
        name = query.data.replace("cocktail_", "")
        await query.message.reply_text(format_cocktail(name), parse_mode="Markdown")
    elif query.data.startswith("zagi_"):
        name = query.data.replace("zagi_", "")
        await query.message.reply_text(format_zagotovka(name), parse_mode="Markdown")
    elif query.data.startswith("tinct_"):
        name = query.data.replace("tinct_", "")
        await query.message.reply_text(format_tincture(name), parse_mode="Markdown")

# ---------- Webhook ----------
@app.route(f"/{TOKEN}", methods=["POST"])
def webhook():
    update = Update.de_json(request.get_json(force=True), application.bot)
    application.update_queue.put_nowait(update)
    return "ok"

if __name__ == "__main__":
    application.add_handler(CommandHandler("start", start))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    application.add_handler(CallbackQueryHandler(handle_callback))
    print("ü§ñ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω —á–µ—Ä–µ–∑ Flask + Webhook.")
    app.run(host="0.0.0.0", port=5000)
